#include "xsensdot.h"

#include <QtEndian>
#include <QDataStream>

#define byteArrayToType( data, order, type ) \
    QDataStream stream( data ); \
    stream.setByteOrder( order ); \
    type t; \
    stream >> t; \
    return t;

qint32 toQInt32( const QByteArray &data,
                 const QDataStream::ByteOrder order=QDataStream::BigEndian )
{ byteArrayToType( data, order, qint32 ) }

const QString XSENSDOT_NOTIFICATION_DESCRIPTOR = "00002902-0000-1000-8000-00805f9b34fb";

const QString XSENSDOT_BATTERY_SERVICE = "15173000-4947-11e9-8646-d663bd873d93";
const QString XSENSDOT_BATTERY_INFO_CHAR = "15173001-4947-11e9-8646-d663bd873d93";

const QString XSENSDOT_MEASUREMENT_SERVICE = "15172000-4947-11e9-8646-d663bd873d93";
const QString XSENSDOT_MEASUREMENT_CONTROL_CHAR = "15172001-4947-11e9-8646-d663bd873d93";
const QString XSENSDOT_MEASUREMENT_MEDIATE_PAYLOAD = "15172003-4947-11e9-8646-d663bd873d93";
const QString XSENSDOT_MEASUREMENT_SHORT_PAYLOAD = "15172004-4947-11e9-8646-d663bd873d93";

const QString XSENSDOT_ORIENTATION_RESET_CHAR = "15172006-4947-11e9-8646-d663bd873d93";
const QString XSENSDOT_ORIENTATION_RESET_RESULT = "15172007-4947-11e9-8646-d663bd873d93";

//Measurement Data type
const QString XSENSDOT_ORIENTATION_EULER = "04";
XsensDot::XsensDot(const QBluetoothDeviceInfo &sensor) : bleDot(sensor)
{
    // look for the needed services
    //! [les-controller-1]
        // Connecting signals and slots for connecting to BLE services.
    controller = QLowEnergyController::createCentral(this->bleDot);
    connect(controller, &QLowEnergyController::connected, this, &XsensDot::deviceConnected);
    connect(controller, &QLowEnergyController::disconnected, this, &XsensDot::deviceDisconnected);
    connect(controller, QOverload<QLowEnergyController::Error>::of(&QLowEnergyController::error), this, &XsensDot::errorReceived);
    connect(controller, &QLowEnergyController::serviceDiscovered, this, &XsensDot::addService);
    connect(controller, &QLowEnergyController::discoveryFinished, this, &XsensDot::serviceScanDone);

//    if (isRandomAddress())
//        controller->setRemoteAddressType(QLowEnergyController::RandomAddress);
//    else
    controller->setRemoteAddressType(QLowEnergyController::PublicAddress);
    controller->connectToDevice();
    //! [les-controller-1]

}

XsensDot::~XsensDot()
{
    if(batteryService != nullptr)
    {
        // unsubscribe battery notification
//       QLowEnergyCharacteristic batteryCharac = batteryService->characteristic(QBluetoothUuid(XSENSDOT_BATTERY_INFO_CHAR));
//        QLowEnergyDescriptor notificationDescriptor = batteryCharac.descriptor(QBluetoothUuid::ClientCharacteristicConfiguration);
//        if(notificationDescriptor.value() == QByteArray::fromHex("0100"))
//            batteryService->writeDescriptor(notificationDescriptor, QByteArray::fromHex("0000"));
//        batteryService->deleteLater();
        delete batteryService;
    }

    if(measurementService != nullptr)
    {
        QLowEnergyCharacteristic measurementCharac = measurementService->characteristic(QBluetoothUuid(XSENSDOT_MEASUREMENT_CONTROL_CHAR));
        // stop measurement process
        measurementService->writeCharacteristic(measurementCharac, QByteArray::fromHex("000105"), QLowEnergyService::WriteWithResponse);
        // unsubscribe measurement notification
//        measurementCharac = measurementService->characteristic(QBluetoothUuid(XSENSDOT_MEASUREMENT_SHORT_PAYLOAD));
//        QLowEnergyDescriptor notificationDescriptor = measurementCharac.descriptor(QBluetoothUuid::ClientCharacteristicConfiguration);
//        if(notificationDescriptor.value() == QByteArray::fromHex("0100"))
//            measurementService->writeDescriptor(notificationDescriptor, QByteArray::fromHex("0000"));
        measurementService->deleteLater();
    }
}
QString XsensDot::getMacAddress() const
{
#ifdef Q_OS_MAC
    // On OS X and iOS we do not have addresses,
    // only unique UUIDs generated by Core Bluetooth.
    return device.deviceUuid().toString();
#else
    return bleDot.address().toString();
#endif
}

QString XsensDot::getName() const
{
    return bleDot.name();
}

void XsensDot::deviceConnected()
{
    qDebug()<< "deviceConnected";
    connected = true;
    //! [les-service-2]
    controller->discoverServices();
    //! [les-service-2]
}

void XsensDot::deviceDisconnected()
{
    qWarning() << "Disconnect from device " << controller->state();
    controller->connectToDevice(); // force the reconnection - add a counter??
    //emit disconnected();
}

void XsensDot::errorReceived(QLowEnergyController::Error error)
{
    qWarning() << "DeviceInfo Error: " << error << " - "<< controller->errorString();
//    emit error(QString("Back\n(%1)").arg(controller->errorString()));
}

void XsensDot::addService(const QBluetoothUuid &serviceUuid)
{
    QLowEnergyService *service = controller->createServiceObject(serviceUuid);
    if (!service) {
        qWarning() << "Cannot create service for uuid";
        return;
    }

    if(serviceUuid.toString().contains(XSENSDOT_BATTERY_SERVICE))
    {
        connect(service, SIGNAL(stateChanged(QLowEnergyService::ServiceState)), this, SLOT(batteryServiceStateChanged(QLowEnergyService::ServiceState)));
        batteryService = service;
        if(service->state() == QLowEnergyService::DiscoveryRequired)
        {
            service->discoverDetails();
        }
    }
    if(serviceUuid.toString().contains(XSENSDOT_MEASUREMENT_SERVICE))
    {
        connect(service, SIGNAL(stateChanged(QLowEnergyService::ServiceState)), this, SLOT(measurementServiceStateChanged(QLowEnergyService::ServiceState)));
        measurementService = service;
        if(service->state() == QLowEnergyService::DiscoveryRequired)
        {
            service->discoverDetails();
        }
    }
    emit servicesUpdated();
}

void XsensDot::serviceScanDone()
{
    // force UI in case we didn't find the required services
    if (batteryService == nullptr && measurementService == nullptr)
        emit servicesUpdated();
    qDebug()<< "service scan done!!";
}

void XsensDot::batteryServiceStateChanged(QLowEnergyService::ServiceState state)
{
     if(state!=QLowEnergyService::ServiceDiscovered  || batteryService ==nullptr)return;

    // activate notification test
    QLowEnergyCharacteristic batteryCharac = batteryService->characteristic(QBluetoothUuid(XSENSDOT_BATTERY_INFO_CHAR));
    if(!batteryCharac.isValid())
    {
        qDebug() << "unable to get Battery service for " << batteryService->serviceUuid().toString();
        return;
    }

    QLowEnergyDescriptor notificationDescriptor = batteryCharac.descriptor(QBluetoothUuid::ClientCharacteristicConfiguration);
    if (!notificationDescriptor.isValid())
    {
        qDebug() << "unable to get Battery descriptor for " << batteryCharac.uuid();
        return;
    }

    // establish hook into notifications
    connect(batteryService, SIGNAL(characteristicChanged(QLowEnergyCharacteristic,QByteArray)), this, SLOT(batteryCharacteristicChanged(QLowEnergyCharacteristic,QByteArray)));

   // activate battery notification
   batteryService->writeDescriptor(notificationDescriptor, QByteArray::fromHex("0100"));
   qDebug()<< "battery notification activated";
   battery = batteryCharac.value().at(0);
   charging = batteryCharac.value().at(1);
   emit batteryUpdated();
}

void XsensDot::measurementServiceStateChanged(QLowEnergyService::ServiceState state)
{
    if(state!=QLowEnergyService::ServiceDiscovered  || measurementService ==nullptr)return;
    // Debug connection : ensure that there is no issued when updating the notification
    connect(measurementService, SIGNAL(descriptorWritten(QLowEnergyDescriptor, QByteArray)), this, SLOT(measurementServiceResetOrientation(QLowEnergyDescriptor, QByteArray)));

    setMeasurementMode(XSENSDOT_ORIENTATION_EULER);
    startMeasuring();
    resetHeading();
}

void XsensDot::batteryCharacteristicChanged(QLowEnergyCharacteristic,QByteArray)
{
    QLowEnergyCharacteristic batteryCharac = batteryService->characteristic(QBluetoothUuid(XSENSDOT_BATTERY_INFO_CHAR));
    battery = batteryCharac.value().at(0);
    charging = batteryCharac.value().at(1);
    qDebug()<<"Battery " << battery << " ("<<charging<<")";
    emit batteryUpdated();
}


void XsensDot::measurementDataCharacteristicChanged(QLowEnergyCharacteristic ,QByteArray newValue)
{
    convertDeviceData(newValue);
}

void XsensDot::measurementServiceResetOrientation(QLowEnergyDescriptor d, QByteArray a)
{
    qDebug()<< d.uuid() <<"  "<<d.value()<<" == " << a;
    QLowEnergyCharacteristic orientationResetChar = measurementService->characteristic(QBluetoothUuid(XSENSDOT_ORIENTATION_RESET_RESULT));
    qDebug()<< orientationResetChar.value();
}

void XsensDot::convertDeviceData(QByteArray &data)
{
    euler.timestamp = toQInt32(data.mid(0,4), QDataStream::LittleEndian);
    euler.x = qFromLittleEndian<float>(data.mid(4,4));
    euler.y = qFromLittleEndian<float>(data.mid(8,4));
    euler.z = qFromLittleEndian<float>(data.mid(12,4));
    qDebug()<<getMacAddress()<<";"<<euler.timestamp<<";"<< euler.x<<";"<<euler.y<<";"<<euler.z;
    emit eulerUpdated(getMacAddress(), euler);
}

void XsensDot::setMeasurementMode(const QString &mode)
{
    QLowEnergyCharacteristic measurementCharac = measurementService->characteristic(QBluetoothUuid(XSENSDOT_MEASUREMENT_CONTROL_CHAR));
    if(!measurementCharac.isValid())
    {
        qDebug() << "unable to get Measurement Control service for " << measurementService->serviceUuid();
        return;
    }
    // activate the measurement process with sensors
    measurementService->writeCharacteristic(measurementCharac, QByteArray::fromHex((QString("0101") + mode).toLatin1()), QLowEnergyService::WriteWithResponse);
}
void XsensDot::startMeasuring()
{
    //subscribe to the notifications of the "measurement" characteristic
    QLowEnergyCharacteristic measurementCharac = measurementService->characteristic(QBluetoothUuid(XSENSDOT_MEASUREMENT_SHORT_PAYLOAD));
    QLowEnergyDescriptor notificationDescriptor = measurementCharac.descriptor(QBluetoothUuid::ClientCharacteristicConfiguration);
    if (!notificationDescriptor.isValid())
    {
        qDebug() << "unable to get Measurement Control descriptor for " << measurementCharac.uuid();
        return;
    }
    // establish hook into notifications
    connect(measurementService, SIGNAL(characteristicChanged(QLowEnergyCharacteristic,QByteArray)), this, SLOT(measurementDataCharacteristicChanged(QLowEnergyCharacteristic,QByteArray)));
    measurementService->writeDescriptor(notificationDescriptor, QByteArray::fromHex("0100"));

    qDebug()<< "measurement notification activated";
}
bool XsensDot::resetHeading()
{
    // reset the orientation measurement
    QLowEnergyCharacteristic orientationResetChar = measurementService->characteristic(QBluetoothUuid(XSENSDOT_ORIENTATION_RESET_CHAR));
    if(!orientationResetChar.isValid())
    {
        qDebug() << "unable to get Orientation Reset characteristic for " << measurementService->serviceUuid();
        return false;
    }
    measurementService->writeCharacteristic(orientationResetChar, QByteArray::fromHex("0001"), QLowEnergyService::WriteWithResponse);
    resetOrientation = true;
    orientationResetChar = measurementService->characteristic(QBluetoothUuid(XSENSDOT_ORIENTATION_RESET_RESULT));
    qDebug()<< "Reset : "<< orientationResetChar.value();
    return orientationResetChar.value().toInt();

}
